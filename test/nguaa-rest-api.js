'use strict';
const crypto = require('crypto');
const logger = require("nguaa-logger");
const NGUAAUtils = require('nguaa-utils');
const HttpServiceClient = new NGUAAUtils.HttpServiceClient();
const logPrefix = "NGUAARestAPI | ";
process.env.UV_THREADPOOL_SIZE = 128;
class NGUAARestAPI {
    /**
     * @description calls RO API
     * @param {*} uid uid of user
     * @param {*} san san of vehicle
     * @param {*} deviceId deviceId of the requesting device
     * @param {*} requestBody encrypted body generated by payload encryption
     * @param {*} iotConstants response from CONFIG table (key=IOT_PROPERTIES,category=IOT)containing constants
     * @returns response from API call
     */
    async callNGUAAAPI(uid, san, deviceId, requestBody,iotConstants, path) {
        var datetime = (new Date()).toISOString().replace(/[:\-]|\.\d{3}/g, '');
        var date = datetime.substr(0, 8);
        var region = "us-east-1";
        var service = "execute-api";
        var credentialString = [date, region, service, 'aws4_request'].join('/');
        var kDate = hmac('AWS4' + process.env.AWS_SECRET_ACCESS_KEY, date);
        // logger.silly("STSTOKENIS AWS_ACCESS_KEY_ID: " + process.env.AWS_ACCESS_KEY_ID);
        // logger.silly("STSTOKENIS AWS_SECRET_ACCESS_KEY: " + process.env.AWS_SECRET_ACCESS_KEY);
        // logger.silly("STSTOKENIS AWS_SESSION_TOKEN: " + process.env.AWS_SESSION_TOKEN);
        var kRegion = hmac(kDate, region);
        var kService = hmac(kRegion, service);
        var kSigning = hmac(kService, 'aws4_request');
        let options = {
            host: iotConstants.NGUAA_REST_API_HOST,
            path: path.replace("{uid}",uid).replace("{san}",san),
            method: 'POST',
            agent: false,
            headers: {
                "content-type": "application/json",
                "host": iotConstants.NGUAA_REST_API_HOST,
                "locale": "en_US",
                "user-agent": iotConstants.NGUAA_REST_API_HEADER_USER_AGENT,
                "x-api-key": iotConstants.NGUAA_REST_API_HEADER_API_KEY,
                "x-clientapp-name": iotConstants.NGUAA_REST_API_HEADER_CLIENTAPP_NAME,
                "x-clientapp-version": iotConstants.NGUAA_REST_API_HEADER_CLIENTAPP_VERSION,
                "x-device-id": deviceId,
                "x-originator-type": iotConstants.NGUAA_REST_API_HEADER_ORIGINATOR_TYPE,
                "x-os-type": iotConstants.NGUAA_REST_API_HEADER_OS_TYPE,
                "x-os-version": iotConstants.NGUAA_REST_API_HEADER_OS_VERSION,
                'Content-Length': Buffer.byteLength(requestBody.body),
                'X-Amz-Security-Token': process.env.AWS_SESSION_TOKEN,
                'X-Amz-Date': datetime
            },
        };
        logger.info(logPrefix + "options is : " + JSON.stringify(options));
        var signedHeaders = Object.keys(options.headers)
            .map(function (k) { return k.toLowerCase(); })
            .sort()
            .join(';');
        var canonicalHeaders = Object.keys(options.headers)
            .sort(function (a, b) { return a.toLowerCase() < b.toLowerCase() ? -1 : 1; })
            .map(function (k) { return k.toLowerCase() + ':' + options.headers[k]; })
            .join('\n');
        var canonicalString = [
            options.method,
            options.path, '',
            canonicalHeaders, '',
            signedHeaders,
            hash(requestBody.body, 'hex'),
        ].join('\n');
        logger.silly(logPrefix + "canonical string" + canonicalString);
        var stringToSign = [
            'AWS4-HMAC-SHA256',
            datetime,
            credentialString,
            hash(canonicalString, 'hex')
        ].join('\n');
        logger.silly(logPrefix + "string To Sign" + stringToSign);
        options.headers.Authorization = [
            'AWS4-HMAC-SHA256 Credential=' + process.env.AWS_ACCESS_KEY_ID + '/' + credentialString,
            'SignedHeaders=' + signedHeaders,
            'Signature=' + hmac(kSigning, stringToSign, 'hex')
        ].join(', ');
        logger.silly(logPrefix + "options is : " + JSON.stringify(options));
        return new Promise((resolve, reject) => {
            logger.streamLog(`${logPrefix} HTTP_Start`);
            HttpServiceClient.callRestAPI(options, requestBody.body)
                .then((httpResponse) => {
                    logger.streamLog(`${logPrefix} HTTP_End`);
                    logger.silly(logPrefix + "  the response data is " + JSON.stringify(httpResponse));
                    resolve(httpResponse);
                }).catch(function (err) {
                    logger.error(logPrefix + "getCallStatus - Catch" + err.stack);
                    throw err;
                }); //end of then
        });
    }
}
exports.NGUAARestAPI = NGUAARestAPI;
function hmac(key, str, encoding) {
    return crypto.createHmac('sha256', key).update(str, 'utf8').digest(encoding);
}
function hash(str, encoding) {
    return crypto.createHash('sha256').update(str, 'utf8').digest(encoding);
}
